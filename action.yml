name: "Business Central AI Code Reviewer"
description: "Run an AI-powered, Business Central specific code review on a Pull Request using OpenAI, Azure OpenAI or OpenRouter.ai."
branding:
  icon:  'package'
  color: 'orange'
author: "Aident GmbH"
version: "1.0.0"

inputs:
  GITHUB_TOKEN:
    description: "GitHub token with repo-scope"
    required: true
    type: string

  AI_PROVIDER:
    description: "openai | azure | openrouter"
    type: string
    default: "azure"

  AI_MODEL:
    description: "AI_MODEL is the base model. For Azure, set AZURE_DEPLOYMENT to your deployments friendly name (falls back to AI_MODEL if omitted)."
    type: string
    default: "o3-mini"

  AI_API_KEY:
    description: "OpenAI API key (required if provider=openai | openrouter)"
    type: string
    required: false

  AZURE_ENDPOINT:
    description: "Azure OpenAI endpoint (required if provider=azure)"
    type: string
    required: false

  AZURE_API_KEY:
    description: "Azure OpenAI API key (required if provider=azure)"
    type: string
    required: false

  AZURE_API_VERSION:
    description: "Azure OpenAI API version"
    type: string
    default: "2025-01-01-preview"

  AZURE_DEPLOYMENT:
    description: "Azure OpenAI deployment name (friendly name you created in Azure)"
    type: string
    required: false

  # Review behaviour
  APPROVE_REVIEWS:
    description: "Let the bot approve / request-changes"
    type: boolean
    default: false

  MAX_COMMENTS:
    description: |
      Maximum inline comments to post.
      0 = unlimited, but GitHub caps a single review at 100 comments
      and a PR at 1000 total.
    type: number
    default: 10

  BASE_PROMPT_EXTRA:
    description: "Free-form text injected into the system prompt (optional)"
    type: string
    default: ""

  # Context customization
  PROJECT_CONTEXT:
    description: "Architecture / guidelines text"
    type: string
    default: ""

  CONTEXT_FILES:
    description: "Comma-separated globs fetched for context"
    type: string
    default: ""

  INCLUDE_PATTERNS:
    description: "Comma-separated globs to include in review"
    type: string
    default: "**/*.al,**/*.xlf,**/*.json"

  EXCLUDE_PATTERNS:
    description: "Comma-separated globs to exclude"
    type: string
    default: ""
  
  # Fetch linked issues
  ISSUE_COUNT:
    description: "Max linked issues to fetch (0 = all)"
    type: number
    default: 0

  FETCH_CLOSED_ISSUES:
    description: "Include closed issues as context"
    type: boolean
    default: true

  AUTO_DETECT_APPS:
    description: "Enable automatic app.json discovery"
    type: boolean
    default: true

  INCLUDE_APP_PERMISSIONS:
    description: "Include *.PermissionSet.al / *.Entitlement.al from each app"
    type: boolean
    default: true

  INCLUDE_APP_MARKDOWN:
    description: "Include *.md files from each app"
    type: boolean
    default: true

  # Guidelines
  GUIDELINE_RULES_PATH:
    description: "Path to JSON or PSD1 file defining custom AL-Guideline rules"
    type: string
    required: false
    default: ""

  DISABLE_GUIDELINEDOCS:
    description: "Skip fetching the official AL-Guidelines docs"
    type: boolean
    default: false

  INCLUDE_CHANGED_FILES_AS_CONTEXT:
    description: "Ship every file that is touched by the PR to the LLM as an extra context file"
    type: boolean
    default: false

  PROMPT_STYLE:
    description: "auto | gpt5 | generic - use GPT-5-optimized prompt when 'gpt-5*' model. 'generic' forces legacy prompt."
    type: string
    default: "auto"

  REASONING_EFFORT:
    description: "low | medium | high - hint for GPT-5 reasoning depth; ignored by other models."
    type: string
    default: "medium"
  LOG_PROMPT:
    description: "Log full prompt (diff + context) to runner logs"
    type: boolean
    default: false
  ENABLE_SERENA:
    description: "Enable Serena MCP enrichment (symbols, where-used, rich snippets)"
    type: boolean
    default: false
  SERENA_URL:
    description: "Serena MCP HTTP endpoint (e.g., http://host:5173/mcp)"
    type: string
    default: ""
  SERENA_TIMEOUT_SEC:
    description: "HTTP timeout (seconds) for Serena tool calls"
    type: number
    default: 20
  SERENA_MAX_REFS:
    description: "Cap for where-used references per symbol"
    type: number
    default: 50
  SERENA_SYMBOL_DEPTH:
    description: "Depth for find_symbol (0 = symbol only)"
    type: number
    default: 1


runs:
  using: composite
  steps:
    - name: Setup Node.js (v20)
      uses: actions/setup-node@v4
      with:
        node-version: 20

    - name: Install diff parser
      shell: pwsh
      working-directory: ${{ github.action_path }}
      run: npm install --no-save parse-diff@latest

    - name: Install uv + mcp-cli
      shell: bash
      run: |
        curl -LsSf https://astral.sh/uv/install.sh | sh
        echo "$HOME/.local/bin" >> $GITHUB_PATH
        python3 -m pip install --user mcp-cli || pipx install mcp-cli
        echo "$HOME/.local/bin" >> $GITHUB_PATH

    - name: Smoke test Serena via MCP (stdio)
      shell: bash
      run: |
        set -euo pipefail
        # mcp-cli launches the server cmd and speaks MCP over stdio
        SERVER_CMD="uvx --from git+https://github.com/oraios/serena serena start-mcp-server --transport stdio"
        # List tools to prove initialize->capabilities exchange works
        mcp-cli --server "$SERVER_CMD" list-tools | tee /tmp/mcp.tools
        # Optionally call a trivial tool to validate request/response
        mcp-cli --server "$SERVER_CMD" call get_current_config | tee /tmp/mcp.get_current_config.json


    # # install uv only when we need a local Serena
    # - name: Install uv (for embedded Serena)
    #   if: ${{ inputs.ENABLE_SERENA == 'true' && inputs.SERENA_URL == '' }}
    #   shell: pwsh
    #   run: |
    #     bash -lc 'curl -LsSf https://astral.sh/uv/install.sh | sh'
    #     Add-Content -Path $env:GITHUB_PATH -Value "$HOME/.local/bin"

    # # start Serena MCP (AL) and wait until healthy
    # - name: Start Serena MCP (AL)
    #   if: ${{ inputs.ENABLE_SERENA == 'true' && inputs.SERENA_URL == '' }}
    #   shell: pwsh
    #   run: |
    #     $port = 5173
    #     $cmd = 'uvx --from git+https://github.com/oraios/serena serena start-mcp-server --transport streamable-http --port {0}' -f $port
    #     bash -lc "nohup $cmd > /tmp/serena.log 2>&1 & echo \$! > /tmp/serena.pid"
    #     $uri = "http://127.0.0.1:$port/mcp"

    #     # --- 1) Handshake: GET once to obtain the session id (server replies 400 + header) ---
    #     $hsHdr = "/tmp/mcp.handshake.headers"
    #     # retry until the server binds; allow 400 since it's expected here
    #     bash -lc "rm -f $hsHdr; curl -sS --retry 120 --retry-delay 1 --retry-connrefused -D $hsHdr -o /dev/null -H 'Accept: text/event-stream' $uri || true"

    #     $sessionId = $null
    #     if (Test-Path $hsHdr -PathType Leaf) {
    #       foreach ($line in Get-Content $hsHdr) {
    #         if ($line -match '^\s*(?i:mcp-session-id)\s*:\s*(\S+)\s*$') { $sessionId = $Matches[1]; break }
    #       }
    #     }
    #     if (-not $sessionId) {
    #       Write-Host 'Serena MCP handshake failed (no Mcp-Session-Id). Tail:'
    #       if (Test-Path /tmp/serena.log) { Get-Content /tmp/serena.log -Tail 200 }
    #       if (Test-Path $hsHdr)          { Write-Host '--- /tmp/mcp.handshake.headers ---'; Get-Content $hsHdr }
    #       bash -lc "test -f /tmp/serena.pid && ps -o pid,cmd -p \$(cat /tmp/serena.pid) || true"
    #       exit 1
    #     }

    #     # --- 2) Open the persistent SSE bound to that session id (must stay open) ---
    #     $hdrFile = "/tmp/mcp.sse.headers"
    #     $curlLog = "/tmp/mcp_sse.err"
    #     bash -lc @"
    #     nohup curl -sS -N \
    #       --retry 120 --retry-delay 1 --retry-connrefused \
    #       -H 'Accept: text/event-stream' \
    #       -H 'Mcp-Session-Id: $sessionId' \
    #       -D $hdrFile $uri >/tmp/mcp_sse.out 2>$curlLog & echo \$! > /tmp/mcp_sse.pid
    #     "@

    #     # Wait for the SSE to report 200 OK
    #     $okSse = $false
    #     for ($i=1; $i -le 60 -and -not $okSse; $i++) {
    #       if (Test-Path $hdrFile -PathType Leaf) {
    #         if ((Select-String -Quiet -Path $hdrFile -Pattern '^HTTP/1\.1 200')) { $okSse = $true; break }
    #       }
    #       Start-Sleep -Seconds 1
    #     }
    #     if (-not $okSse) {
    #       Write-Host 'Serena MCP SSE did not establish (no 200). Tail:'
    #       if (Test-Path /tmp/serena.log) { Get-Content /tmp/serena.log -Tail 200 }
    #       if (Test-Path $hdrFile)        { Write-Host '--- /tmp/mcp.sse.headers ---'; Get-Content $hdrFile }
    #       if (Test-Path $curlLog)        { Write-Host '--- /tmp/mcp_sse.err ---'; Get-Content $curlLog -Tail 100 }
    #       bash -lc "test -f /tmp/mcp_sse.pid && ps -o pid,cmd -p \$(cat /tmp/mcp_sse.pid) || true"
    #       exit 1
    #     }

    #     # --- 3) Initialize JSON-RPC over POST using the same session id ---
    #     $body = @{
    #       jsonrpc = "2.0"
    #       id      = "1"
    #       method  = "initialize"
    #       params  = @{ protocolVersion = "2024-10-07"; capabilities = @{} }
    #     } | ConvertTo-Json -Depth 5

    #     $ok = $false
    #     for ($i=1; $i -le 10; $i++) {
    #       try {
    #         $resp = Invoke-RestMethod -Method Post -Uri $uri `
    #           -ContentType 'application/json' `
    #           -Headers @{ Accept='application/json'; 'Mcp-Session-Id' = $sessionId } `
    #           -Body $body -TimeoutSec 10
    #         if ($resp -and $resp.result) { $ok = $true; break }
    #       } catch { Start-Sleep -Seconds 1 }
    #     }
    #     if (-not $ok) {
    #       Write-Host 'Serena MCP did not initialize. Tail:'
    #       if (Test-Path /tmp/serena.log) { Get-Content /tmp/serena.log -Tail 200 }
    #       if (Test-Path $hdrFile)        { Write-Host '--- /tmp/mcp.sse.headers ---'; Get-Content $hdrFile }
    #       exit 1
    #     }

    #     # Expose to later steps
    #     "SERENA_URL=$uri"         | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ascii
    #     "SERENA_SESSION_ID=$sessionId" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ascii

    - name: Run AI Code Review
      shell: pwsh
      env:
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_EVENT_PATH: ${{ github.event_path }}
        OPENAI_API_KEY: ${{ inputs.AI_API_KEY }}
        AZURE_OPENAI_API_KEY: ${{ inputs.AZURE_API_KEY }}
        AZURE_OPENAI_ENDPOINT: ${{ inputs.AZURE_ENDPOINT }}
      run: |
        . '${{ github.action_path }}/scripts/main.ps1'
        if ($Env:AZURE_OPENAI_ENDPOINT) { Write-Host "::add-mask::$Env:AZURE_OPENAI_ENDPOINT" }
        if ($Env:AZURE_OPENAI_API_KEY)  { Write-Host "::add-mask::$Env:AZURE_OPENAI_API_KEY" }
        if ($Env:OPENAI_API_KEY)  { Write-Host "::add-mask::$Env:OPENAI_API_KEY" }
        
        $p = @{
          GitHubToken        = '${{ inputs.GITHUB_TOKEN }}'
          Provider           = '${{ inputs.AI_PROVIDER }}'
          Model              = '${{ inputs.AI_MODEL }}'
          MaxComments        = [int]'${{ inputs.MAX_COMMENTS }}'
          ProjectContext     = '${{ inputs.PROJECT_CONTEXT }}'
          ContextFiles       = '${{ inputs.CONTEXT_FILES }}'
          IncludePatterns    = '${{ inputs.INCLUDE_PATTERNS }}'
          ExcludePatterns    = '${{ inputs.EXCLUDE_PATTERNS }}'
          IssueCount         = [int]'${{ inputs.ISSUE_COUNT }}'
          AutoDetectApps        = [bool]::Parse('${{ inputs.AUTO_DETECT_APPS }}')
          IncludeAppPermissions = [bool]::Parse('${{ inputs.INCLUDE_APP_PERMISSIONS }}')
          IncludeAppMarkdown    = [bool]::Parse('${{ inputs.INCLUDE_APP_MARKDOWN }}')
          BasePromptExtra    = '${{ inputs.BASE_PROMPT_EXTRA }}'
          GuidelineRulesPath = '${{ inputs.GUIDELINE_RULES_PATH }}'
          DisableGuidelineDocs    = [switch]::new([bool]::Parse('${{ inputs.DISABLE_GUIDELINEDOCS }}'))
          IncludeChangedFilesAsContext = [bool]::Parse('${{ inputs.INCLUDE_CHANGED_FILES_AS_CONTEXT }}')
          PromptStyle        = '${{ inputs.PROMPT_STYLE }}'
          ReasoningEffort    = '${{ inputs.REASONING_EFFORT }}'
          LogPrompt = [switch]::new([bool]::Parse('${{ inputs.LOG_PROMPT }}'))
          EnableSerena          = [bool]::Parse('${{ inputs.ENABLE_SERENA }}')
          SerenaUrl             = '${{ inputs.SERENA_URL }}'
          SerenaTimeoutSec      = [int]'${{ inputs.SERENA_TIMEOUT_SEC }}'
          SerenaMaxRefs         = [int]'${{ inputs.SERENA_MAX_REFS }}'
          SerenaSymbolDepth     = [int]'${{ inputs.SERENA_SYMBOL_DEPTH }}'
        }
        if ('${{ inputs.APPROVE_REVIEWS }}' -eq 'true')  { $p.ApproveReviews  = $true }
        if ('${{ inputs.FETCH_CLOSED_ISSUES }}' -eq 'true') { $p.FetchClosedIssues = $true }
        if (-not $p.SerenaUrl -and $Env:SERENA_URL) { $p.SerenaUrl = $Env:SERENA_URL }

        if ($p.Provider -in @('openai','openrouter')) {
          $p.ApiKey = $Env:OPENAI_API_KEY
          $p.Remove('AzureEndpoint')
          $p.Remove('AzureApiKey')
          $p.Remove('AzureApiVersion')
          $p.Remove('AZURE_DEPLOYMENT')
        } else {
          $p.AzureEndpoint   = $Env:AZURE_OPENAI_ENDPOINT
          $p.AzureApiKey     = $Env:AZURE_OPENAI_API_KEY
          $p.AzureApiVersion = '${{ inputs.AZURE_API_VERSION }}'
          $p.Remove('ApiKey')
          if ('${{ inputs.AZURE_DEPLOYMENT }}') {
            $p.AzureDeployment = '${{ inputs.AZURE_DEPLOYMENT }}'
          }
        }

        Invoke-AICodeReview @p

    - name: Stop Serena MCP
      if: ${{ inputs.ENABLE_SERENA == 'true' && inputs.SERENA_URL == '' }}
      shell: pwsh
      run: |
        if (Test-Path /tmp/serena.pid) {
          $pid = Get-Content /tmp/serena.pid
          Write-Host "Stopping Serena PID $pid"
          kill -TERM $pid 2>$null || $true
        }