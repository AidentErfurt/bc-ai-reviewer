name: "Business Central AI Code Reviewer"
description: "Run an AI-powered, Business Central specific code review on a Pull Request using OpenAI, Azure OpenAI or OpenRouter.ai."
branding:
  icon:  'package'
  color: 'orange'
author: "Aident GmbH"
version: "1.0.0"

inputs:
  GITHUB_TOKEN:
    description: "GitHub token with repo-scope"
    required: true
    type: string

  AI_PROVIDER:
    description: "openai | azure | openrouter"
    type: string
    default: "azure"

  AI_MODEL:
    description: "AI_MODEL is the base model. For Azure, set AZURE_DEPLOYMENT to your deployments friendly name (falls back to AI_MODEL if omitted)."
    type: string
    default: "o3-mini"

  AI_API_KEY:
    description: "OpenAI API key (required if provider=openai | openrouter)"
    type: string
    required: false

  AZURE_ENDPOINT:
    description: "Azure OpenAI endpoint (required if provider=azure)"
    type: string
    required: false

  AZURE_API_KEY:
    description: "Azure OpenAI API key (required if provider=azure)"
    type: string
    required: false

  AZURE_API_VERSION:
    description: "Azure OpenAI API version"
    type: string
    default: "2025-01-01-preview"

  AZURE_DEPLOYMENT:
    description: "Azure OpenAI deployment name (friendly name you created in Azure)"
    type: string
    required: false

  # Review behaviour
  APPROVE_REVIEWS:
    description: "Let the bot approve / request-changes"
    type: boolean
    default: false

  MAX_COMMENTS:
    description: |
      Maximum inline comments to post.
      0 = unlimited, but GitHub caps a single review at 100 comments
      and a PR at 1000 total.
    type: number
    default: 10

  BASE_PROMPT_EXTRA:
    description: "Free-form text injected into the system prompt (optional)"
    type: string
    default: ""

  # Context customization
  PROJECT_CONTEXT:
    description: "Architecture / guidelines text"
    type: string
    default: ""
  CONTEXT_FILES:
    description: "Comma-separated globs fetched for context"
    type: string
    default: ""
  INCLUDE_PATTERNS:
    description: "Comma-separated globs to include in review"
    type: string
    default: "**/*.al,**/*.xlf,**/*.json"
  EXCLUDE_PATTERNS:
    description: "Comma-separated globs to exclude"
    type: string
    default: ""

  # Issues context
  ISSUE_COUNT:
    description: "Max linked issues to fetch (0 = all)"
    type: number
    default: 0
  FETCH_CLOSED_ISSUES:
    description: "Include closed issues as context"
    type: boolean
    default: true

  # App detection
  AUTO_DETECT_APPS:
    description: "Enable automatic app.json discovery"
    type: boolean
    default: true
  INCLUDE_APP_PERMISSIONS:
    description: "Include *.PermissionSet.al / *.Entitlement.al from each app"
    type: boolean
    default: true
  INCLUDE_APP_MARKDOWN:
    description: "Include *.md files from each app"
    type: boolean
    default: true

  # Guidelines
  GUIDELINE_RULES_PATH:
    description: "Path to JSON or PSD1 file defining custom AL-Guideline rules"
    type: string
    default: ""
  DISABLE_GUIDELINEDOCS:
    description: "Skip fetching the official AL-Guidelines docs"
    type: boolean
    default: false

  # Prompting
  INCLUDE_CHANGED_FILES_AS_CONTEXT:
    description: "Ship every file that is touched by the PR to the LLM as an extra context file"
    type: boolean
    default: false
  PROMPT_STYLE:
    description: "auto | gpt5 | generic"
    type: string
    default: "auto"
  REASONING_EFFORT:
    description: "low | medium | high"
    type: string
    default: "medium"
  LOG_PROMPT:
    description: "Log full prompt (diff + context) to runner logs"
    type: boolean
    default: false

  # Serena (MCP over HTTP)
  ENABLE_SERENA:
    description: "Enable Serena MCP enrichment (symbols, where-used, rich snippets)"
    type: boolean
    default: false
  SERENA_URL:
    description: "Serena MCP HTTP endpoint (e.g., http://host:5173/mcp). If empty, this action starts a local instance."
    type: string
    default: ""
  SERENA_TIMEOUT_SEC:
    description: "HTTP timeout (seconds) for Serena tool calls"
    type: number
    default: 60
  SERENA_MAX_REFS:
    description: "Cap for where-used references per symbol"
    type: number
    default: 50
  SERENA_SYMBOL_DEPTH:
    description: "Depth for find_symbol (0 = symbol only)"
    type: number
    default: 1

runs:
  using: composite
  steps:
    - name: Setup Node.js (v20)
      uses: actions/setup-node@v4
      with:
        node-version: 20

    - name: Install diff parser
      shell: pwsh
      working-directory: ${{ github.action_path }}
      run: npm install --no-save parse-diff@latest

    # Serena needs Python 3.11 (rejects 3.12)
    - name: Setup Python 3.11 for Serena
      if: ${{ inputs.ENABLE_SERENA == 'true' && inputs.SERENA_URL == '' }}
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install & Start Serena (HTTP)
      if: ${{ inputs.ENABLE_SERENA == 'true' && inputs.SERENA_URL == '' }}
      shell: pwsh
      run: |
        # Ensure local bin on PATH
        "$HOME/.local/bin" | Out-File -FilePath $env:GITHUB_PATH -Append -Encoding ascii
        $env:PATH = "$HOME/.local/bin" + [IO.Path]::PathSeparator + $env:PATH

        # Use the Python 3.11
        $pyDir = $env:pythonLocation
        if (-not $pyDir) { throw "pythonLocation env var not set by setup-python." }
        $py = Join-Path $pyDir "bin/python"

        # Install pipx + Serena
        & $py -m pip install --user --upgrade pip pipx | Out-String | Write-Host
        & $py -m pipx ensurepath | Out-String | Write-Host
        & $py -m pipx install --python "$py" "git+https://github.com/oraios/serena" | Out-String | Write-Host

        $serena = Get-Command serena -ErrorAction Stop
        Write-Host "Serena binary: $($serena.Source)"

        # Start HTTP MCP server with recommended context
        $port = 5173
        $base = "http://127.0.0.1:$port"
        $SerenaUrl = "$base/mcp"
        $out = "/tmp/serena_http.out"
        $err = "/tmp/serena_http.err"

        # --- Start server via dedicated entrypoint ---
        $proc = Start-Process -FilePath "serena-mcp-server" `
          -ArgumentList @(
            '--transport','streamable-http',
            '--port',"$port",
            '--context','ide-assistant'
          ) `
          -WorkingDirectory $env:GITHUB_WORKSPACE `
          -PassThru -NoNewWindow `
          -RedirectStandardOutput $out -RedirectStandardError $err
        $SerenaPid = $proc.Id
        Write-Host "Serena PID: $SerenaPid"

        # --- Wait for HTTP to answer before header probing ---
        $deadline = (Get-Date).AddSeconds(25)
        $ready = $false
        do {
          try {
            # try a quick GET; any status that isn't "cannot connect" means listener is up
            $resp = Invoke-WebRequest -Uri "$base/mcp" -Method GET -Headers @{Accept='text/event-stream'} -TimeoutSec 2 -SkipHttpErrorCheck
            $ready = $true
          } catch {
            # connection refused / timeout -> not ready yet
            if ($proc.HasExited) {
              Write-Host "-- serena stdout (tail) --"; if (Test-Path $out) { Get-Content $out -Tail 150 }
              Write-Host "-- serena stderr (tail) --"; if (Test-Path $err) { Get-Content $err -Tail 150 }
              throw "Serena process exited before HTTP became ready."
            }
            Start-Sleep -Milliseconds 300
          }
        } while (-not $ready -and (Get-Date) -lt $deadline)

        if (-not $ready) {
          Write-Host "-- serena stdout (tail) --"; if (Test-Path $out) { Get-Content $out -Tail 150 }
          Write-Host "-- serena stderr (tail) --"; if (Test-Path $err) { Get-Content $err -Tail 150 }
          throw "Serena HTTP endpoint didnâ€™t become reachable at $base/mcp."
        }

        # --- Robust header probe (HEAD, GET, curl) ---
        function Get-Serena-Session {
          param([string]$Url)
          Write-Host "== Probing Serena at $Url =="
          $sessionId = $null; $headerName = $null

          function Dump-Headers([hashtable]$h){ if($h){ foreach($k in $h.Keys){ Write-Host "  $($k): $($h[$k])" } } }

          try {
            $h = Invoke-WebRequest -Uri $Url -Method HEAD -TimeoutSec 3 -SkipHttpErrorCheck
            Write-Host "-- HEAD headers --"; Dump-Headers $h.Headers
            foreach($cand in @('Mcp-Session-Id','Mcp-Session')){ if($h.Headers[$cand]){ $sessionId = "$($h.Headers[$cand])".Trim(); $headerName=$cand; break } }
            if ($sessionId){ return [pscustomobject]@{ Id=$sessionId; Name=$headerName } }
          } catch { Write-Host "HEAD failed: $($_.Exception.Message)" }

          try {
            $g = Invoke-WebRequest -Uri $Url -Method GET -Headers @{Accept='text/event-stream'} -TimeoutSec 4 -SkipHttpErrorCheck
            Write-Host "-- GET headers --"; Dump-Headers $g.Headers
            foreach($cand in @('Mcp-Session-Id','Mcp-Session')){ if($g.Headers[$cand]){ $sessionId = "$($g.Headers[$cand])".Trim(); $headerName=$cand; break } }
            if ($sessionId){ return [pscustomobject]@{ Id=$sessionId; Name=$headerName } }
          } catch { Write-Host "GET failed: $($_.Exception.Message)" }

          try {
            $raw = & /usr/bin/curl -sS -D - -o /dev/null -H 'Accept: text/event-stream' "$Url"
            $rawNoCR = $raw -replace "`r",""
            Write-Host "-- curl -D - raw headers --"; $rawNoCR -split "`n" | ForEach-Object { Write-Host "  $_" }
            $m = [regex]::Match($rawNoCR, '(?im)^\s*(Mcp-Session-Id|Mcp-Session)\s*:\s*(.+?)\s*$')
            if ($m.Success){ return [pscustomobject]@{ Id=$m.Groups[2].Value.Trim(); Name=$m.Groups[1].Value } }
          } catch { Write-Host "curl probe failed: $($_.Exception.Message)" }

          return $null
        }

        $urlsToTry = @("$base/mcp","$base/mcp/","$base/")
        $session = $null
        foreach($u in $urlsToTry){ $session = Get-Serena-Session -Url $u; if($session){ $SerenaUrl = $u; break } }

        if (-not $session) {
          Write-Host "-- serena stdout (tail) --"; if (Test-Path $out) { Get-Content $out -Tail 150 }
          Write-Host "-- serena stderr (tail) --"; if (Test-Path $err) { Get-Content $err -Tail 150 }
          throw "Serena handshake failed: no Mcp session header found."
        }

        Write-Host "Using session header name: $($session.Name)"
        Write-Host "Using session id value : $($session.Id)"

        # ---- Initialize over SSE ----
        $initBodyObj = @{
          jsonrpc = '2.0'
          id      = 'init-1'
          method  = 'initialize'
          params  = @{
            protocolVersion = '2024-10-07'
            capabilities    = @{}
            clientInfo      = @{ name='bc-ai-reviewer'; version='0.1.0' }
          }
        }
        $initBody = $initBodyObj | ConvertTo-Json -Depth 8

        # Put BOTH headers explicitly in -Headers so nothing overwrites Accept
        $headers = @{
          $session.Name = $session.Id
          'Accept'      = 'application/json, text/event-stream'
          'Content-Type'= 'application/json'
        }

        # Use Invoke-WebRequest (returns raw content string), not Invoke-RestMethod
        $resp = Invoke-WebRequest -Uri $SerenaUrl -Method POST -Headers $headers -Body $initBody -SkipHttpErrorCheck
        [string]$rawText = $resp.Content

        # Parse SSE: grab the last "data: {...}" line
        $lastJsonLine = ($rawText -split "`n" | Where-Object { $_.TrimStart().StartsWith('data: ') }) | Select-Object -Last 1
        if (-not $lastJsonLine) {
          Write-Host "Initialize response (raw): $rawText"
          throw "Serena initialize failed: no SSE data line."
        }
        $jsonPart = $lastJsonLine.Substring($lastJsonLine.IndexOf('data: ') + 6).Trim()
        $initObj = $null
        try { $initObj = $jsonPart | ConvertFrom-Json } catch { }

        if (-not $initObj) {
          Write-Host "Initialize response (raw): $rawText"
          throw "Serena initialize failed: invalid JSON in SSE payload."
        }
        if ($initObj.error) {
          Write-Host "Initialize response (raw): $rawText"
          throw "Serena initialize failed: $($initObj.error.code) $($initObj.error.message)"
        }
        if (-not $initObj.result) {
          Write-Host "Initialize response (raw): $rawText"
          throw "Serena initialize failed: no result in initialize response."
        }

        # Success -> export env vars
        "SERENA_URL=$SerenaUrl"               | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ascii
        "SERENA_SESSION_ID=$($session.Id)"    | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ascii
        "SERENA_SESSION_HDR=$($session.Name)" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ascii
        Write-Host "SERENA_URL set to $SerenaUrl"
        Write-Host "SERENA_SESSION_ID captured."




        # # ---- Optional: activate every app.json parent as a Serena project ----
        # Write-Host "== app.json discovery =="
        # $apps = Get-ChildItem -Path $env:GITHUB_WORKSPACE -Filter 'app.json' -Recurse -File -ErrorAction SilentlyContinue
        # if ($apps) {
        #   $apps | ForEach-Object { Write-Host "â€¢ $($_.FullName)" }
        #   foreach ($app in $apps) {
        #     $projDir = Split-Path $app.FullName -Parent
        #     Write-Host "Activating project: $projDir"
        #     $callBody = @{
        #       jsonrpc = '2.0'
        #       id = [guid]::NewGuid().ToString()
        #       method = 'tools/call'
        #       params = @{
        #         name = 'activate_project'
        #         arguments = @{ project = $projDir }
        #       }
        #     } | ConvertTo-Json -Depth 10 -Compress
        #     try {
        #       Invoke-RestMethod -Uri $SerenaUrl -Method Post -ContentType 'application/json' -Headers @{ 'Mcp-Session-Id' = $sessionId } -Body $callBody | Out-Null
        #     } catch {
        #       Write-Warning "activate_project failed for $projDir: $($_.Exception.Message)"
        #     }
        #   }
        # } else {
        #   Write-Host "No app.json found under $env:GITHUB_WORKSPACE"
        # }

    - name: Serena connection & health check
      if: ${{ inputs.ENABLE_SERENA == 'true' && inputs.SERENA_URL == '' }}
      shell: pwsh
      run: |
        $Url = $Env:SERENA_URL
        $Sid = $Env:SERENA_SESSION_ID
        $Hdr = $Env:SERENA_SESSION_HDR
        if (-not $Url -or -not $Sid -or -not $Hdr) { throw "SERENA_URL / SERENA_SESSION_ID / SERENA_SESSION_HDR not set." }

        # use the same timeout we expose as an input (fallback 60)
        $TimeoutSec = [int](${Env:SERENA_TIMEOUT_SEC} ?? 60)

        function New-SerenaHeaders {
          param([string]$Sid,[string]$Hdr)
          $h = @{}
          $h[$Hdr] = $Sid
          $h['Accept']       = 'application/json, text/event-stream'
          $h['Content-Type'] = 'application/json'
          return $h
        }

        function Parse-SerenaResponse {
          param([string]$Raw)
          $trim = $Raw.Trim()
          if ($trim.StartsWith('{')) {
            return ($trim | ConvertFrom-Json)
          }
          # SSE: pick the last data: line
          $last = ($Raw -split "`n" | Where-Object { $_.TrimStart().StartsWith('data: ') }) | Select-Object -Last 1
          if (-not $last) { throw "No SSE data line in response." }
          $json = $last.Substring($last.IndexOf('data: ') + 6).Trim()
          return ($json | ConvertFrom-Json)
        }

        function Invoke-SerenaRpc {
          param([string]$Id,[string]$Method,[hashtable]$Params)
          $body    = @{ jsonrpc='2.0'; id=$Id; method=$Method; params=$Params } | ConvertTo-Json -Depth 20
          $headers = New-SerenaHeaders -Sid $Sid -Hdr $Hdr
          $resp    = Invoke-WebRequest -Uri $Url -Method POST -Headers $headers -Body $body -TimeoutSec $TimeoutSec -SkipHttpErrorCheck
          $obj     = Parse-SerenaResponse -Raw ([string]$resp.Content)
          if ($obj.error) { throw "RPC $Method failed: $($obj.error.code) $($obj.error.message)" }
          return $obj
        }

        function Invoke-SerenaTool {
          param([string]$Name,[hashtable]$Args)
          Invoke-SerenaRpc -Id ([guid]::NewGuid()) -Method 'tools/call' -Params @{ name=$Name; arguments=$Args }
        }

        Write-Host "== tools/list =="
        $tools = Invoke-SerenaRpc -Id 'list-1' -Method 'tools/list' -Params @{}
        if (-not $tools.result.tools) { throw "Serena tools not listed." }

        Write-Host "== get_current_config =="
        $cfg = Invoke-SerenaTool -Name 'get_current_config' -Args @{}
        $txt = $cfg.result.content[0].text
        Write-Host $txt

        # Activate detected apps (optional but helpful)
        $apps = Get-ChildItem -Path $env:GITHUB_WORKSPACE -Filter 'app.json' -Recurse -File -ErrorAction SilentlyContinue
        if ($apps) {
          foreach ($app in $apps) {
            $proj = Split-Path $app.FullName -Parent
            Write-Host "Activating project: $proj"
            try { Invoke-SerenaTool -Name 'activate_project' -Args @{ project = $proj } | Out-Null } catch { Write-Warning $_ }
          }
        }

        Write-Host "== find_file (**/*.al) =="
        $ff = Invoke-SerenaTool -Name 'find_file' -Args @{ pattern = '**/*.al' }
        $found = ($ff.result.content[0].text -split "`n") | Where-Object { $_ -match '\.al$' }
        if (-not $found) { throw "Serena find_file found no .al files. Is the project activated correctly?" }
        Write-Host ("Found sample: " + $found[0])

        $firstAl = $found[0].Trim()
        Write-Host "== get_symbols_overview ($firstAl) =="
        try {
          $ov = Invoke-SerenaTool -Name 'get_symbols_overview' -Args @{ relative_path = $firstAl }
          ($ov.result.content[0].text | Select-Object -First 80) | Write-Host
        } catch {
          Write-Warning "get_symbols_overview failed (continuing): $($_.Exception.Message)"
        }

        Write-Host "Serena health check OK."

    - name: Run AI Code Review
      shell: pwsh
      env:
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_EVENT_PATH: ${{ github.event_path }}
        OPENAI_API_KEY: ${{ inputs.AI_API_KEY }}
        AZURE_OPENAI_API_KEY: ${{ inputs.AZURE_API_KEY }}
        AZURE_OPENAI_ENDPOINT: ${{ inputs.AZURE_ENDPOINT }}
      run: |
        . '${{ github.action_path }}/scripts/main.ps1'
        if ($Env:AZURE_OPENAI_ENDPOINT) { Write-Host "::add-mask::$Env:AZURE_OPENAI_ENDPOINT" }
        if ($Env:AZURE_OPENAI_API_KEY)  { Write-Host "::add-mask::$Env:AZURE_OPENAI_API_KEY" }
        if ($Env:OPENAI_API_KEY)        { Write-Host "::add-mask::$Env:OPENAI_API_KEY" }
        $p = @{
          GitHubToken        = '${{ inputs.GITHUB_TOKEN }}'
          Provider           = '${{ inputs.AI_PROVIDER }}'
          Model              = '${{ inputs.AI_MODEL }}'
          MaxComments        = [int]'${{ inputs.MAX_COMMENTS }}'
          ProjectContext     = '${{ inputs.PROJECT_CONTEXT }}'
          ContextFiles       = '${{ inputs.CONTEXT_FILES }}'
          IncludePatterns    = '${{ inputs.INCLUDE_PATTERNS }}'
          ExcludePatterns    = '${{ inputs.EXCLUDE_PATTERNS }}'
          IssueCount         = [int]'${{ inputs.ISSUE_COUNT }}'
          AutoDetectApps        = [bool]::Parse('${{ inputs.AUTO_DETECT_APPS }}')
          IncludeAppPermissions = [bool]::Parse('${{ inputs.INCLUDE_APP_PERMISSIONS }}')
          IncludeAppMarkdown    = [bool]::Parse('${{ inputs.INCLUDE_APP_MARKDOWN }}')
          BasePromptExtra    = '${{ inputs.BASE_PROMPT_EXTRA }}'
          GuidelineRulesPath = '${{ inputs.GUIDELINE_RULES_PATH }}'
          DisableGuidelineDocs    = [switch]::new([bool]::Parse('${{ inputs.DISABLE_GUIDELINEDOCS }}'))
          IncludeChangedFilesAsContext = [bool]::Parse('${{ inputs.INCLUDE_CHANGED_FILES_AS_CONTEXT }}')
          PromptStyle        = '${{ inputs.PROMPT_STYLE }}'
          ReasoningEffort    = '${{ inputs.REASONING_EFFORT }}'
          LogPrompt          = [switch]::new([bool]::Parse('${{ inputs.LOG_PROMPT }}'))
          EnableSerena       = [bool]::Parse('${{ inputs.ENABLE_SERENA }}')
          SerenaUrl          = '${{ inputs.SERENA_URL }}'
          SerenaTimeoutSec   = [int]'${{ inputs.SERENA_TIMEOUT_SEC }}'
          SerenaMaxRefs      = [int]'${{ inputs.SERENA_MAX_REFS }}'
          SerenaSymbolDepth  = [int]'${{ inputs.SERENA_SYMBOL_DEPTH }}'
        }
        if ('${{ inputs.APPROVE_REVIEWS }}' -eq 'true')  { $p.ApproveReviews  = $true }
        if ('${{ inputs.FETCH_CLOSED_ISSUES }}' -eq 'true') { $p.FetchClosedIssues = $true }
        if (-not $p.SerenaUrl -and $Env:SERENA_URL) { $p.SerenaUrl = $Env:SERENA_URL }

        if ($p.Provider -in @('openai','openrouter')) {
          $p.ApiKey = $Env:OPENAI_API_KEY
          $p.Remove('AzureEndpoint')
          $p.Remove('AzureApiKey')
          $p.Remove('AzureApiVersion')
          $p.Remove('AZURE_DEPLOYMENT')
        } else {
          $p.AzureEndpoint   = $Env:AZURE_OPENAI_ENDPOINT
          $p.AzureApiKey     = $Env:AZURE_OPENAI_API_KEY
          $p.AzureApiVersion = '${{ inputs.AZURE_API_VERSION }}'
          $p.Remove('ApiKey')
          if ('${{ inputs.AZURE_DEPLOYMENT }}') { $p.AzureDeployment = '${{ inputs.AZURE_DEPLOYMENT }}' }
        }

        Invoke-AICodeReview @p

    - name: Stop Serena HTTP
      if: ${{ inputs.ENABLE_SERENA == 'true' && inputs.SERENA_URL == '' }}
      shell: pwsh
      run: |
        if (Test-Path /tmp/serena_http.pid) {
          $SerenaPidFromFile = Get-Content /tmp/serena_http.pid
          Write-Host "Stopping Serena PID $SerenaPidFromFile"
          try { Stop-Process -Id $SerenaPidFromFile -ErrorAction SilentlyContinue } catch {}
        }
